<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HA Satellite Orb — Particle Field (Flow) + Tunables</title>
  <style>
    :root{--bg:#05030a;--text:rgba(255,255,255,.9);--muted:rgba(255,255,255,.65);--accent:#b06cff;}
    html,body{height:100%;margin:0;overflow:hidden;background:
      radial-gradient(1200px 700px at 50% 35%, rgba(120,60,255,.12), transparent 55%),
      radial-gradient(900px 600px at 55% 60%, rgba(60,210,255,.06), transparent 60%),
      var(--bg);
      color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;
    }
    #wrap{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr auto;gap:12px;padding:14px;}
    header{
      display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:12px;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.10);border-radius:14px;padding:10px 12px;backdrop-filter: blur(10px);
      box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    .left{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    .badge{padding:6px 10px;border-radius:999px;font-size:12px;letter-spacing:.4px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.05);display:flex;align-items:center;gap:8px;}
    .badge strong{color:var(--accent)}
    .badge input[type="range"]{width:120px;}
    .btns{display:flex;gap:8px;flex-wrap:wrap;}
    button{
      appearance:none;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.05);color:var(--text);
      padding:9px 12px;border-radius:12px;cursor:pointer;transition:transform .06s ease, background .15s ease, border-color .15s ease;
      font-weight:600;letter-spacing:.2px;font-size:13px;
    }
    button:hover{background:rgba(255,255,255,.08);border-color:rgba(255,255,255,.22);}
    button:active{transform:translateY(1px);}
    button.primary{border-color:rgba(176,108,255,.4);box-shadow:0 0 0 2px rgba(176,108,255,.10) inset;}
    button.danger{border-color:rgba(255,90,138,.45);box-shadow:0 0 0 2px rgba(255,90,138,.10) inset;}
    main{position:relative;border-radius:18px;overflow:hidden;border:1px solid rgba(255,255,255,.10);
      background:radial-gradient(900px 500px at 50% 30%, rgba(176,108,255,.10), transparent 55%);
      box-shadow:0 20px 50px rgba(0,0,0,.45);
    }
    canvas{position:absolute;inset:0;width:100%;height:100%;}
    footer{
      display:grid;grid-template-columns:1fr auto;gap:10px;align-items:center;
      background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.10);border-radius:14px;padding:10px 12px;backdrop-filter: blur(10px);
    }
    #log{font-size:13px;color:var(--muted);display:flex;flex-direction:column;gap:6px;min-height:42px;}
    #log .row{display:flex;gap:10px;align-items:baseline;flex-wrap:wrap;}
    #log code{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);padding:2px 6px;border-radius:8px;color:rgba(255,255,255,.85)}
    .hint{font-size:12px;color:rgba(255,255,255,.55);}
  </style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="left">
      <div class="badge">State: <strong id="stateLabel">Idle</strong></div>
      <div class="badge">Mic: <strong id="micLabel">Off</strong></div>
      <div class="badge">SpeechRec: <strong id="srLabel">Off</strong></div>
      <div class="badge">Audio env: <strong id="envLabel">0.00</strong></div>

      <div class="badge">Density <strong id="densVal">6</strong>
        <input id="densitySlider" type="range" min="1" max="10" step="1" value="6">
      </div>
      <div class="badge">Orbit <strong id="orbitVal">5</strong>
        <input id="orbitSlider" type="range" min="1" max="10" step="1" value="5">
      </div>
    </div>
    <div class="btns">
      <button id="btnIdle" class="primary">Idle</button>
      <button id="btnListen">Listening</button>
      <button id="btnRespond">Responding (Mic + Talk)</button>
      <button id="btnStop" class="danger">Stop Mic</button>
    </div>
  </header>

  <main><canvas id="c"></canvas></main>

  <footer>
    <div id="log">
      <div class="row"><span>Tip:</span> <span class="hint">Mic requires <code>https://</code> or <code>http://localhost</code>. (Visuals work without mic.)</span></div>
      <div class="row"><span>Status:</span> <span id="statusText">Ready.</span></div>
      <div class="row"><span>Heard:</span> <code id="heardText">—</code></div>
    </div>
    <div class="hint" style="text-align:right">Flow-field particles • no rays</div>
  </footer>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:true });
  // Offscreen layer for particle trails (persistent buffer)
  const pCan = document.createElement("canvas");
  const pCtx = pCan.getContext("2d", { alpha:true });


  // UI
  const stateLabel=document.getElementById("stateLabel");
  const micLabel=document.getElementById("micLabel");
  const srLabel=document.getElementById("srLabel");
  const envLabel=document.getElementById("envLabel");
  const statusText=document.getElementById("statusText");
  const heardText=document.getElementById("heardText");

  const densVal=document.getElementById("densVal");
  const orbitVal=document.getElementById("orbitVal");
  const densitySlider=document.getElementById("densitySlider");
  const orbitSlider=document.getElementById("orbitSlider");

  const btnIdle=document.getElementById("btnIdle");
  const btnListen=document.getElementById("btnListen");
  const btnRespond=document.getElementById("btnRespond");
  const btnStop=document.getElementById("btnStop");

  const setStatus=(s)=>statusText.textContent=s;
  const setHeard=(s)=>heardText.textContent=s||"—";

  const States=Object.freeze({IDLE:"Idle",LISTENING:"Listening",RESPONDING:"Responding"});
  let state=States.IDLE;
  function setState(next){
    state=next;
    stateLabel.textContent=next;
    btnIdle.classList.toggle("primary", next===States.IDLE);
    btnListen.classList.toggle("primary", next===States.LISTENING);
    btnRespond.classList.toggle("primary", next===States.RESPONDING);
  }

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;

  // Resize
  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const r = canvas.getBoundingClientRect();
    canvas.width = Math.floor(r.width*dpr);
    canvas.height = Math.floor(r.height*dpr);
    pCan.width = canvas.width;
    pCan.height = canvas.height;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    // keep particle layer in same CSS pixels coordinates
    pCtx.setTransform(dpr,0,0,dpr,0,0);
    return {w:r.width,h:r.height,dpr};
  }
  window.addEventListener("resize", resize, {passive:true});
  resize();

  // Tunables
  let density = 6; // 1-10
  let orbit = 5;   // 1-10
  function syncTunables(){
    density = parseInt(densitySlider.value,10);
    orbit = parseInt(orbitSlider.value,10);
    densVal.textContent = String(density);
    orbitVal.textContent = String(orbit);
    // rebuild particle pool when density changes
    targetCount = densityToCount(density);
    if (particles.length < targetCount) {
      for (let i=particles.length; i<targetCount; i++) particles.push(makeParticle());
    } else if (particles.length > targetCount) {
      particles.length = targetCount;
    }
  }
  densitySlider.addEventListener("input", syncTunables);
  orbitSlider.addEventListener("input", syncTunables);

  // Audio (mic)
  let audioCtx=null, micStream=null, analyser=null, data=null;
  async function startMic(){
    if(micStream) return true;
    try{
      micStream = await navigator.mediaDevices.getUserMedia({audio:{
        echoCancellation:true, noiseSuppression:true, autoGainControl:true
      }});
      audioCtx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();
      const src = audioCtx.createMediaStreamSource(micStream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize=2048;
      analyser.smoothingTimeConstant=0.78;
      src.connect(analyser);
      data = new Uint8Array(analyser.fftSize);
      micLabel.textContent="On";
      setStatus("Mic active.");
      return true;
    }catch(e){
      micLabel.textContent="Off";
      setStatus("Mic permission failed (need https or localhost).");
      console.error(e);
      return false;
    }
  }
  function stopMic(){
    if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream=null; }
    analyser=null; data=null;
    micLabel.textContent="Off";
    setStatus("Mic stopped.");
  }
  function pollAudio(){
    if(!analyser||!data) return {rms:0, peak:0};
    analyser.getByteTimeDomainData(data);
    let sum=0, peak=0;
    for(let i=0;i<data.length;i++){
      const v=(data[i]-128)/128;
      const av=Math.abs(v);
      sum += v*v;
      if(av>peak) peak=av;
    }
    const rms=Math.sqrt(sum/data.length);
    return {rms: clamp(rms*2.2,0,1), peak: clamp(peak*1.25,0,1)};
  }

  // Speech (same simple logic)
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  let recog=null, recognizing=false, speaking=false;

  function setupSpeechRec(){
    if(!SpeechRecognition){ srLabel.textContent="N/A"; return null; }
    if(recog) return recog;
    recog = new SpeechRecognition();
    recog.lang="en-US";
    recog.interimResults=true;
    recog.continuous=false;

    recog.onstart=()=>{ recognizing=true; srLabel.textContent="On"; setStatus("Listening for speech…"); };
    recog.onend=()=>{ recognizing=false; srLabel.textContent="Off"; if(state===States.RESPONDING && !speaking) setStatus("Say something…"); };
    recog.onerror=(e)=>{ srLabel.textContent="Err"; setStatus(`Speech recognition error: ${e.error}`); };

    let finalText="";
    recog.onresult=(evt)=>{
      let interim="";
      for(let i=evt.resultIndex;i<evt.results.length;i++){
        const res=evt.results[i];
        const txt=res[0]?.transcript||"";
        if(res.isFinal) finalText += txt; else interim += txt;
      }
      setHeard((finalText+" "+interim).trim());
      const last=evt.results[evt.results.length-1];
      if(last && last.isFinal){
        const cleaned=finalText.trim();
        if(cleaned){ respondToText(cleaned); finalText=""; }
      }
    };
    return recog;
  }
  function safeStartRecognition(){
    const r=setupSpeechRec();
    if(!r){ setStatus("Speech recognition unavailable. (Chrome/Edge recommended)"); return; }
    if(recognizing) return;
    try{ r.start(); }catch{}
  }
  function stopRecognition(){
    if(recog && recognizing){ try{ recog.stop(); }catch{} }
    recognizing=false;
    srLabel.textContent = SpeechRecognition ? "Off" : "N/A";
  }
  function speak(text){
    return new Promise((resolve)=>{
      if(!("speechSynthesis" in window)){ setStatus("TTS not supported."); resolve(false); return; }
      window.speechSynthesis.cancel();
      const u=new SpeechSynthesisUtterance(text);
      u.rate=1.0; u.pitch=1.05; u.volume=1.0;
      speaking=true; setStatus("Speaking…");
      u.onend=()=>{ speaking=false; setStatus(state===States.RESPONDING?"Speaking finished. Listening again…":"Done."); resolve(true); if(state===States.RESPONDING) safeStartRecognition(); };
      u.onerror=()=>{ speaking=false; setStatus("TTS error."); resolve(false); if(state===States.RESPONDING) safeStartRecognition(); };
      window.speechSynthesis.speak(u);
    });
  }
  function respondToText(userText){
    const t=userText.toLowerCase().trim();
    let reply=`I heard: ${userText}.`;
    if(t.includes("hello")||t.includes("hi")) reply="Hello. I'm awake and listening.";
    if(t.includes("what time")) reply=`It is ${new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"})}.`;
    if(t.includes("your name")) reply="I'm your Home Assistant satellite prototype.";
    if(t.includes("thank")) reply="You're welcome.";
    speak(reply);
  }

  // Buttons
  btnIdle.onclick=()=>{ setState(States.IDLE); stopRecognition(); setStatus("Idle."); };
  btnListen.onclick=async()=>{ setState(States.LISTENING); const ok=await startMic(); if(ok) setStatus("Listening visuals active."); };
  btnRespond.onclick=async()=>{
    setState(States.RESPONDING);
    const ok=await startMic(); if(!ok) return;
    setupSpeechRec();
    if(!SpeechRecognition){ setStatus("Speech recognition unavailable. Try Chrome/Edge."); speak("Speech recognition isn't available in this browser."); return; }
    setStatus("Responding mode. Say something…");
    safeStartRecognition();
  };
  btnStop.onclick=()=>{ stopRecognition(); stopMic(); window.speechSynthesis?.cancel?.(); setStatus("All stopped."); };

  // ===== Flow-field particle system =====
  // Value noise helpers
  function hash2(x,y){
    // integer hash -> [0,1)
    const n = (x*374761393 + y*668265263) ^ (x*1274126177);
    return fract(Math.sin(n)*43758.5453123);
  }
  function fract(v){ return v - Math.floor(v); }
  function smoothstep(a,b,t){
    t = clamp((t-a)/(b-a), 0, 1);
    return t*t*(3-2*t);
  }
  function noise(x,y){
    const xi = Math.floor(x), yi = Math.floor(y);
    const xf = x-xi, yf = y-yi;
    const a = hash2(xi, yi);
    const b = hash2(xi+1, yi);
    const c = hash2(xi, yi+1);
    const d = hash2(xi+1, yi+1);
    const u = xf*xf*(3-2*xf);
    const v = yf*yf*(3-2*yf);
    return lerp(lerp(a,b,u), lerp(c,d,u), v);
  }
  function fbm(x,y){
    let v=0, a=0.5;
    for(let i=0;i<4;i++){
      v += a*noise(x,y);
      x = x*2.02 + 19.7;
      y = y*2.02 - 7.3;
      a *= 0.5;
    }
    return v;
  }
  function curlAngle(x,y,t){
    // compute pseudo-curl from fbm gradients
    const e = 0.12;
    const n1 = fbm(x, y + e + t);
    const n2 = fbm(x, y - e + t);
    const a = (n1 - n2) / (2*e);
    const n3 = fbm(x + e, y + t);
    const n4 = fbm(x - e, y + t);
    const b = (n3 - n4) / (2*e);
    // perpendicular gives curl-ish direction
    return Math.atan2(a, -b);
  }

  function densityToCount(d){
    // 1..10 -> 250..2200
    return Math.floor(250 + (d-1)*(1950/9));
  }

  let targetCount = densityToCount(density);
  const particles = [];

  function randn(){
    // quick-ish gaussian-ish for nicer spread
    return (Math.random()+Math.random()+Math.random()+Math.random()-2.0);
  }

  let cx=0, cy=0, shellR=120;

  function makeParticle(){
    const ang = Math.random()*Math.PI*2;
    // orbit controls mean radius: 1->mostly inside, 10->more corona
    const orbit01 = (orbit-1)/9;
    const inner = 0.15 + 0.55*(1-orbit01);  // more inside at low orbit
    const outer = 0.85 + 0.55*(orbit01);    // more outside at high orbit
    const rr = shellR * clamp(inner + Math.random()*(outer-inner), 0.08, 1.55);
    return {
      x: cx + Math.cos(ang)*rr,
      y: cy + Math.sin(ang)*rr,
      px: cx + Math.cos(ang)*rr,
      py: cy + Math.sin(ang)*rr,
      z: Math.random(),  // depth
      seed: Math.random()*1000,
      life: 2 + Math.random()*4,
      age: Math.random()*6,
    };
  }

  function respawn(p){
    const ang = Math.random()*Math.PI*2;
    const orbit01 = (orbit-1)/9;
    const inner = 0.15 + 0.55*(1-orbit01);
    const outer = 0.85 + 0.55*(orbit01);
    const rr = shellR * clamp(inner + Math.random()*(outer-inner), 0.08, 1.55);
    p.x = cx + Math.cos(ang)*rr;
    p.y = cy + Math.sin(ang)*rr;
    p.px = p.x;
    p.py = p.y;
    p.z = Math.random();
    p.seed = Math.random()*1000;
    p.life = 2 + Math.random()*4;
    p.age = 0;
  }

  // init pool
  for(let i=0;i<targetCount;i++) particles.push(makeParticle());
  syncTunables();

  // Orb sizing (uses your “great sizing” logic)
  const orb = {radius:110, focus:0, speak:0, envFast:0, env:0};
  let last = performance.now();

  function drawBackground(w,h,t){
    // clear + soft blobs
    ctx.clearRect(0,0,w,h);

    const vg = ctx.createRadialGradient(w/2,h/2,0,w/2,h/2,Math.max(w,h)*0.75);
    vg.addColorStop(0,"rgba(0,0,0,0)");
    vg.addColorStop(1,"rgba(0,0,0,0.65)");
    ctx.fillStyle=vg;
    ctx.fillRect(0,0,w,h);

    for(let i=0;i<3;i++){
      const ph=t*0.00009*(i+1);
      const x=w*(0.35+0.35*Math.sin(ph+i*2.1));
      const y=h*(0.28+0.25*Math.cos(ph*1.1+i*1.7));
      const r=Math.min(w,h)*(0.28+0.08*Math.sin(ph*1.9+i));
      const g=ctx.createRadialGradient(x,y,0,x,y,r);
      g.addColorStop(0,"rgba(176,108,255,0.08)");
      g.addColorStop(0.55,"rgba(124,240,255,0.03)");
      g.addColorStop(1,"rgba(0,0,0,0)");
      ctx.fillStyle=g;
      ctx.fillRect(0,0,w,h);
    }
  }

  function drawCore(cx,cy,r,focus,speak,envFast,t){
    const corePulse=0.5+0.5*Math.sin(t*0.012 + envFast*2.2);
    const coreR = r*(0.46 + 0.07*corePulse + 0.04*envFast);
    const shellR = r*(0.90 + 0.04*Math.sin(t*0.0012+1.3) + 0.06*envFast);

    // glow
    const glowStrength = 0.18 + 0.20*focus + 0.28*speak + 0.22*envFast;
    const glow=ctx.createRadialGradient(cx,cy,coreR*0.2,cx,cy,shellR*1.55);
    glow.addColorStop(0,`rgba(176,108,255,${0.20+0.12*speak})`);
    glow.addColorStop(0.35,`rgba(176,108,255,${glowStrength})`);
    glow.addColorStop(0.62,`rgba(124,240,255,${0.06+0.08*speak+0.10*envFast})`);
    glow.addColorStop(1,"rgba(0,0,0,0)");
    ctx.fillStyle=glow;
    ctx.fillRect(cx-shellR*1.7, cy-shellR*1.7, shellR*3.4, shellR*3.4);

    // body
    const body=ctx.createRadialGradient(cx-coreR*0.18, cy-coreR*0.22, coreR*0.2, cx, cy, shellR);
    body.addColorStop(0,`rgba(255,255,255,${0.20+0.14*speak+0.08*envFast})`);
    body.addColorStop(0.18,`rgba(235,205,255,${0.16+0.10*speak})`);
    body.addColorStop(0.45,`rgba(176,108,255,${0.34+0.18*focus+0.20*speak+0.06*envFast})`);
    body.addColorStop(0.78,"rgba(80,30,130,0.55)");
    body.addColorStop(1,"rgba(20,8,35,0.75)");

    ctx.beginPath();
    ctx.arc(cx,cy,shellR,0,Math.PI*2);
    ctx.fillStyle=body;
    ctx.fill();

    // fluid/turbulent motion inside the core (sun/water-cooling vibe)
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx,cy,shellR*0.98,0,Math.PI*2);
    ctx.clip();
    ctx.globalCompositeOperation="screen";

    // drifting "turbulence" blobs
    const blobCount = 18 + Math.floor(10*envFast) + Math.floor(6*speak);
    for(let i=0;i<blobCount;i++){
      const a = (t*0.0009)*(0.8+i*0.07) + i*1.7;
      const rr = shellR*(0.10 + 0.78*Math.abs(Math.sin(i*1.2 + t*0.0012)));
      const x = cx + Math.cos(a*1.2)*rr*0.9;
      const y = cy + Math.sin(a*1.05)*rr*0.75;
      const s = shellR*(0.28 + 0.18*Math.sin(i + t*0.0011))*(0.9+0.25*envFast);
      const g = ctx.createRadialGradient(x,y,0,x,y,s);
      g.addColorStop(0,`rgba(124,240,255,${0.02+0.05*envFast+0.03*speak})`);
      g.addColorStop(0.35,`rgba(176,108,255,${0.03+0.07*focus+0.05*speak+0.06*envFast})`);
      g.addColorStop(1,"rgba(0,0,0,0)");
      ctx.fillStyle=g;
      ctx.fillRect(cx-shellR, cy-shellR, shellR*2, shellR*2);
    }

    // "coolant specks" circulating inside
    const speckN = 70 + Math.floor(140*envFast) + Math.floor(90*speak);
    for(let i=0;i<speckN;i++){
      const u = i/speckN;
      const ang = u*Math.PI*2 + t*0.0026*(0.6+1.2*envFast);
      const rad = shellR*(0.15 + 0.80*Math.sqrt((u*13.37)%1.0));
      const x = cx + Math.cos(ang)*rad*(0.9+0.06*Math.sin(t*0.001+u*9));
      const y = cy + Math.sin(ang)*rad*(0.9+0.06*Math.cos(t*0.0013+u*7));
      const s = 0.6 + 1.8*((u*97.3)%1.0) * (0.6+0.9*envFast);
      ctx.fillStyle = `rgba(255,255,255,${0.02+0.05*envFast+0.03*speak})`;
      ctx.fillRect(x,y,s,s);
    }

    ctx.globalCompositeOperation="source-over";
    ctx.restore();

    // rim
    ctx.strokeStyle=`rgba(255,255,255,${0.10+0.08*focus+0.10*speak+0.06*envFast})`;
    ctx.lineWidth=1.2;
    ctx.beginPath(); ctx.arc(cx,cy,shellR*0.985,0,Math.PI*2); ctx.stroke();

    return shellR;
  }

  function step(now){
    const dt = Math.min(50, now-last);
    last = now;

    const {w,h} = resize();
    const audio = pollAudio();

    // envelope followers
    const atkFast=0.42, relFast=0.08;
    orb.envFast = (audio.peak>orb.envFast) ? lerp(orb.envFast,audio.peak,atkFast) : lerp(orb.envFast,audio.peak,relFast);
    const target=clamp(audio.rms*0.75+audio.peak*0.55,0,1);
    const atk=0.12, rel=0.06;
    orb.env = (target>orb.env) ? lerp(orb.env,target,atk) : lerp(orb.env,target,rel);
    envLabel.textContent = orb.envFast.toFixed(2);

    const focusT=(state===States.LISTENING || state===States.RESPONDING)?1:0;
    const speakT=(state===States.RESPONDING)?1:0;
    orb.focus = lerp(orb.focus, focusT, 0.06);
    orb.speak = lerp(orb.speak, speakT, 0.06);

    // Base size: keep idle/listen same; responding halfway (0.18 speak factor)
    const base = Math.min(w,h)*0.16;
    const R = base*(1.0 + 0.10*orb.focus + 0.18*orb.speak);
    orb.radius = lerp(orb.radius, R, 0.08);

    // Tuned pulse (not huge)
    const breathe=0.5+0.5*Math.sin(now*0.0022);
    const pulseKick = (orb.speak>0.01) ? (0.06 + 0.32*orb.envFast + 0.10*orb.envFast*orb.envFast) : (0.08*orb.envFast);
    let r = orb.radius*(1.0 + 0.05*breathe*(1-orb.focus) + 0.10*orb.focus + 0.08*orb.speak + pulseKick);
    const maxR = Math.min(w,h)*0.32;
    r = Math.min(r, maxR);

    cx = w/2;
    cy = h/2 + h*0.02;

    drawBackground(w,h,now);

    // core first (so particles can be screened on top)
    shellR = drawCore(cx,cy,r,orb.focus,orb.speak,orb.envFast,now);

    // Update particles target count live
    // (syncTunables handles resizing array; we just keep respawns stable)
    targetCount = densityToCount(density);

    // Particle behavior controls
    const orbit01 = (orbit-1)/9;
    const innerKeep = shellR*(0.20 + 0.50*(1-orbit01));
    const outerKeep = shellR*(1.05 + 0.55*(orbit01)); // can go slightly beyond shell
    const speed = (18 + 52*orb.envFast) * (0.65 + 0.75*orb.speak + 0.35*orb.focus);

    // Particle render (persistent trails on offscreen layer)
    // Fade particle layer slightly each frame to create tails
    pCtx.save();
    pCtx.globalCompositeOperation = "source-over";
    // lower alpha = longer trails
    pCtx.fillStyle = "rgba(0,0,0,0.04)"; // longer, more visible trails
    pCtx.fillRect(0,0,w,h);
    pCtx.restore();

    pCtx.save();
    pCtx.globalCompositeOperation = "lighter";

    const t = now*0.001;
    for(let i=0;i<particles.length;i++){
      const p = particles[i];
      p.age += dt/1000;
      if(p.age > p.life) { respawn(p); }

      // normalized coords around center
      const dx = (p.x - cx) / shellR;
      const dy = (p.y - cy) / shellR;
      const dist = Math.sqrt(dx*dx + dy*dy) + 1e-6;

      // flow direction from curl-ish noise
      const f = 1.25; // field frequency
      const ang = curlAngle(dx*f + p.seed*0.001, dy*f + p.seed*0.001, t*0.35);
      // tangential bias keeps "orbit"
      const tang = Math.atan2(dy, dx) + Math.PI/2;
      const mixAmt = 0.55 + 0.35*orbit01; // higher orbit -> more tangential
      const dir = lerpAngle(ang, tang, mixAmt);

      const vx = Math.cos(dir) * speed * (0.35 + 0.9*p.z);
      const vy = Math.sin(dir) * speed * (0.35 + 0.9*p.z);

      // gentle radial spring to keep in band
      const radial = (dist*shellR);
      let ax=0, ay=0;
      if(radial < innerKeep){
        const push = (innerKeep - radial)/innerKeep;
        ax += (dx/dist) * speed * 0.55 * push;
        ay += (dy/dist) * speed * 0.55 * push;
      } else if(radial > outerKeep){
        const pull = (radial - outerKeep)/outerKeep;
        ax -= (dx/dist) * speed * 0.75 * pull;
        ay -= (dy/dist) * speed * 0.75 * pull;
      }

      // integrate
      p.px = p.x; p.py = p.y;
      p.x += (vx + ax) * (dt/1000);
      p.y += (vy + ay) * (dt/1000);

      // if far off, respawn
      const ddx = p.x - cx, ddy = p.y - cy;
      const rr = Math.sqrt(ddx*ddx + ddy*ddy);
      if(rr > shellR*1.9) { respawn(p); continue; }

      // brightness/size
      const life01 = p.age / p.life;
      const fade = Math.sin(Math.PI * (1-life01));
      const rimBoost = smoothstep(shellR*0.75, shellR*1.15, rr);
      const alpha = (0.05 + 0.22*fade) * (0.70 + 0.75*orb.envFast) * (0.55 + 0.55*p.z) * (0.55 + 0.55*rimBoost);
      const size = (0.55 + 2.0*p.z) * (0.7 + 0.9*orb.envFast);

      // color shifts between purple/cyan subtly
      const hue = 270 + 22*Math.sin(p.seed + t*0.7) + 18*rimBoost;

      // tail: draw faint segment from previous to current
      pCtx.strokeStyle = `hsla(${hue}, 95%, ${60 + 12*p.z}%, ${alpha*0.85})`;
      pCtx.lineWidth = Math.max(0.6, size*0.6);
      pCtx.beginPath();
      pCtx.moveTo(p.px, p.py);
      pCtx.lineTo(p.x, p.y);
      pCtx.stroke();

      // head
      pCtx.fillStyle = `hsla(${hue}, 95%, ${62 + 12*p.z}%, ${Math.min(1,alpha*1.15)})`;
      pCtx.beginPath();
      pCtx.arc(p.x, p.y, size, 0, Math.PI*2);
      pCtx.fill();
    }
    pCtx.restore();

    // Composite particle layer onto main canvas
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.globalAlpha = 1.0;
    ctx.drawImage(pCan, 0, 0, w, h);
    ctx.restore();

    requestAnimationFrame(step);
  }

  function lerpAngle(a,b,t){
    // shortest path
    let d = (b - a + Math.PI*3)%(Math.PI*2) - Math.PI;
    return a + d*t;
  }

  // Init
  setState(States.IDLE);
  srLabel.textContent = SpeechRecognition ? "Off" : "N/A";
  setStatus("Ready. Use Density/Orbit sliders — this version uses particles, not rays.");
  syncTunables();
  requestAnimationFrame(step);

  document.addEventListener("visibilitychange", ()=>{
    if(document.hidden){
      stopRecognition(); stopMic(); window.speechSynthesis?.cancel?.();
    }
  });
})();
</script>
</body>
</html>
